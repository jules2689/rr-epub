# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cli-ui` gem.
# Please instead update this file by running `bin/tapioca gem cli-ui`.


# source://cli-ui//lib/cli/ui.rb#7
module CLI; end

# source://cli-ui//lib/cli/ui.rb#8
module CLI::UI
  class << self
    # Convenience Method for +CLI::UI::Prompt.ask+
    #
    # source://cli-ui//lib/cli/ui.rb#106
    sig do
      params(
        question: ::String,
        options: T.nilable(T::Array[::String]),
        default: T.nilable(T.any(::String, T::Array[::String])),
        is_file: T::Boolean,
        allow_empty: T::Boolean,
        multiple: T::Boolean,
        filter_ui: T::Boolean,
        select_ui: T::Boolean,
        options_proc: T.nilable(T.proc.params(handler: ::CLI::UI::Prompt::OptionsHandler).void)
      ).returns(T.any(::String, T::Array[::String]))
    end
    def ask(question, options: T.unsafe(nil), default: T.unsafe(nil), is_file: T.unsafe(nil), allow_empty: T.unsafe(nil), multiple: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil), &options_proc); end

    # Convenience Method for +CLI::UI::Prompt.confirm+
    #
    # ==== Attributes
    #
    # * +question+ - question to confirm
    #
    # source://cli-ui//lib/cli/ui.rb#88
    sig { params(question: ::String, default: T::Boolean).returns(T::Boolean) }
    def confirm(question, default: T.unsafe(nil)); end

    # Turn colour output in Formatter on or off.
    #
    # ==== Attributes
    #
    # * +bool+ - true or false; enable or disable colour.
    #
    # source://cli-ui//lib/cli/ui.rb#337
    sig { params(bool: T::Boolean).void }
    def enable_color=(bool); end

    # Check whether colour is enabled in Formatter output. By default, colour
    # is enabled when STDOUT is a TTY; that is, when output has not been
    # redirected to another program or to a file.
    #
    # source://cli-ui//lib/cli/ui.rb#326
    sig { returns(T::Boolean) }
    def enable_color?; end

    # Convenience Method to format text using +CLI::UI::Formatter.format+
    # Check +CLI::UI::Formatter::SGR_MAP+ for available formatting options
    #
    # https://user-images.githubusercontent.com/3074765/33799827-6d0721a2-dd01-11e7-9ab5-c3d455264afe.png
    # https://user-images.githubusercontent.com/3074765/33799847-9ec03fd0-dd01-11e7-93f7-5f5cc540e61e.png
    #
    # ==== Attributes
    #
    # * +input+ - input to format
    #
    # ==== Options
    #
    # * +enable_color+ - should color be used? default to true unless output is redirected.
    #
    # source://cli-ui//lib/cli/ui.rb#161
    sig { params(input: ::String, enable_color: T::Boolean).returns(::String) }
    def fmt(input, enable_color: T.unsafe(nil)); end

    # Convenience Method for +CLI::UI::Frame.open+
    #
    # ==== Attributes
    #
    # * +args+ - arguments for +Frame.open+
    # * +block+ - block for +Frame.open+
    #
    # source://cli-ui//lib/cli/ui.rb#226
    sig do
      type_parameters(:T)
        .params(
          text: ::String,
          color: T.nilable(T.any(::CLI::UI::Color, ::String, ::Symbol)),
          failure_text: T.nilable(::String),
          success_text: T.nilable(::String),
          timing: T.any(::Numeric, T::Boolean),
          frame_style: T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol),
          block: T.nilable(T.proc.returns(T.type_parameter(:T)))
        ).returns(T.nilable(T.type_parameter(:T)))
    end
    def frame(text, color: T.unsafe(nil), failure_text: T.unsafe(nil), success_text: T.unsafe(nil), timing: T.unsafe(nil), frame_style: T.unsafe(nil), &block); end

    # Set the default frame style.
    # Convenience method for setting the default frame style with +CLI::UI::Frame.frame_style=+
    #
    # Raises ArgumentError if +frame_style+ is not valid
    #
    # ==== Attributes
    #
    # * +symbol+ - the default frame style to use for frames
    #
    # source://cli-ui//lib/cli/ui.rb#351
    sig { params(frame_style: T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol)).void }
    def frame_style=(frame_style); end

    # Glyph resolution using +CLI::UI::Glyph.lookup+
    # Look at the method signature for +Glyph.lookup+ for more details
    #
    # ==== Attributes
    #
    # * +handle+ - handle of the glyph to resolve
    #
    # source://cli-ui//lib/cli/ui.rb#44
    sig { params(handle: ::String).returns(::CLI::UI::Glyph) }
    def glyph(handle); end

    # Create a terminal link
    #
    # source://cli-ui//lib/cli/ui.rb#357
    sig { params(url: ::String, text: ::String, format: T::Boolean, blue_underline: T::Boolean).returns(::String) }
    def link(url, text, format: T.unsafe(nil), blue_underline: T.unsafe(nil)); end

    # Duplicate output to a file path
    #
    # ==== Attributes
    #
    # * +path+ - path to duplicate output to
    #
    # source://cli-ui//lib/cli/ui.rb#288
    sig do
      type_parameters(:T)
        .params(
          path: ::String,
          block: T.proc.returns(T.type_parameter(:T))
        ).returns(T.type_parameter(:T))
    end
    def log_output_to(path, &block); end

    # Convenience Method for +CLI::UI::Printer.puts+
    #
    # ==== Attributes
    #
    # * +msg+ - Message to print
    # * +kwargs+ - keyword arguments for +Printer.puts+
    #
    # source://cli-ui//lib/cli/ui.rb#188
    sig do
      params(
        msg: ::String,
        frame_color: T.nilable(T.any(::CLI::UI::Color, ::String, ::Symbol)),
        to: T.any(::IO, ::StringIO),
        encoding: ::Encoding,
        format: T::Boolean,
        graceful: T::Boolean,
        wrap: T::Boolean
      ).void
    end
    def puts(msg, frame_color: T.unsafe(nil), to: T.unsafe(nil), encoding: T.unsafe(nil), format: T.unsafe(nil), graceful: T.unsafe(nil), wrap: T.unsafe(nil)); end

    # Disable all framing within a block
    #
    # ==== Attributes
    #
    # * +block+ - block in which to disable frames
    #
    # source://cli-ui//lib/cli/ui.rb#313
    sig { type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T)) }
    def raw(&block); end

    # Color resolution using +CLI::UI::Color.lookup+
    # Will lookup using +Color.lookup+ unless it's already a CLI::UI::Color (or nil)
    #
    # ==== Attributes
    #
    # * +input+ - color to resolve
    #
    # source://cli-ui//lib/cli/ui.rb#56
    sig { params(input: T.any(::CLI::UI::Color, ::String, ::Symbol)).returns(::CLI::UI::Color) }
    def resolve_color(input); end

    # Frame style resolution using +CLI::UI::Frame::FrameStyle.lookup+.
    # Will lookup using +FrameStyle.lookup+ unless it's already a CLI::UI::Frame::FrameStyle(or nil)
    #
    # ==== Attributes
    #
    # * +input+ - frame style to resolve
    #
    # source://cli-ui//lib/cli/ui.rb#72
    sig do
      params(
        input: T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol)
      ).returns(::CLI::UI::Frame::FrameStyle)
    end
    def resolve_style(input); end

    # Convenience Method to resolve text using +CLI::UI::Formatter.format+
    # Check +CLI::UI::Formatter::SGR_MAP+ for available formatting options
    #
    # ==== Attributes
    #
    # * +input+ - input to format
    # * +truncate_to+ - number of characters to truncate the string to (or nil)
    #
    # source://cli-ui//lib/cli/ui.rb#139
    sig { params(input: ::String, truncate_to: T.nilable(::Integer)).returns(::String) }
    def resolve_text(input, truncate_to: T.unsafe(nil)); end

    # Convenience Method for +CLI::UI::Spinner.spin+
    #
    # ==== Attributes
    #
    # * +args+ - arguments for +Spinner.open+
    # * +block+ - block for +Spinner.open+
    #
    # source://cli-ui//lib/cli/ui.rb#257
    sig do
      params(
        title: ::String,
        auto_debrief: T::Boolean,
        block: T.proc.params(task: ::CLI::UI::Spinner::SpinGroup::Task).void
      ).returns(T::Boolean)
    end
    def spinner(title, auto_debrief: T.unsafe(nil), &block); end

    # Convenience Method to override frame color using +CLI::UI::Frame.with_frame_color+
    #
    # ==== Attributes
    #
    # * +color+ - color to override to
    # * +block+ - block for +Frame.with_frame_color_override+
    #
    # source://cli-ui//lib/cli/ui.rb#273
    sig do
      type_parameters(:T)
        .params(
          color: T.any(::CLI::UI::Color, ::String, ::Symbol),
          block: T.proc.returns(T.type_parameter(:T))
        ).returns(T.type_parameter(:T))
    end
    def with_frame_color(color, &block); end

    # source://cli-ui//lib/cli/ui.rb#166
    sig { params(input: ::String).returns(::String) }
    def wrap(input); end
  end
end

# source://cli-ui//lib/cli/ui/ansi.rb#7
module CLI::UI::ANSI
  class << self
    # source://cli-ui//lib/cli/ui/ansi.rb#179
    sig { returns(::String) }
    def clear_to_end_of_line; end

    # Returns an ANSI control sequence
    #
    # ==== Attributes
    #
    # - +args+ - Argument to pass to the ANSI control sequence
    # - +cmd+ - ANSI control sequence Command
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#59
    sig { params(args: ::String, cmd: ::String).returns(::String) }
    def control(args, cmd); end

    # Move the cursor back n columns
    #
    # ==== Attributes
    #
    # * +n+ - number of columns by which to move the cursor back
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#117
    sig { params(n: ::Integer).returns(::String) }
    def cursor_back(n = T.unsafe(nil)); end

    # Move the cursor down n lines
    #
    # ==== Attributes
    #
    # * +n+ - number of lines by which to move the cursor down
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#91
    sig { params(n: ::Integer).returns(::String) }
    def cursor_down(n = T.unsafe(nil)); end

    # Move the cursor forward n columns
    #
    # ==== Attributes
    #
    # * +n+ - number of columns by which to move the cursor forward
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#104
    sig { params(n: ::Integer).returns(::String) }
    def cursor_forward(n = T.unsafe(nil)); end

    # Move the cursor to a specific column
    #
    # ==== Attributes
    #
    # * +n+ - The column to move to
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#130
    sig { params(n: ::Integer).returns(::String) }
    def cursor_horizontal_absolute(n = T.unsafe(nil)); end

    # Restore the saved cursor position
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#160
    sig { returns(::String) }
    def cursor_restore; end

    # Save the cursor position
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#153
    sig { returns(::String) }
    def cursor_save; end

    # Move the cursor up n lines
    #
    # ==== Attributes
    #
    # * +n+ - number of lines by which to move the cursor up
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#78
    sig { params(n: ::Integer).returns(::String) }
    def cursor_up(n = T.unsafe(nil)); end

    # Hide the cursor
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#146
    sig { returns(::String) }
    def hide_cursor; end

    # Move to the next line
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#167
    sig { returns(::String) }
    def next_line; end

    # Move to the previous line
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#174
    sig { returns(::String) }
    def previous_line; end

    # ANSI escape sequences (like \x1b[31m) have zero width.
    # when calculating the padding width, we must exclude them.
    # This also implements a basic version of utf8 character width calculation like
    # we could get for real from something like utf8proc.
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#21
    sig { params(str: ::String).returns(::Integer) }
    def printing_width(str); end

    # https://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#65
    sig { params(params: ::String).returns(::String) }
    def sgr(params); end

    # Show the cursor
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#139
    sig { returns(::String) }
    def show_cursor; end

    # Strips ANSI codes from a str
    #
    # ==== Attributes
    #
    # - +str+ - The string from which to strip codes
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#47
    sig { params(str: ::String).returns(::String) }
    def strip_codes(str); end
  end
end

# source://cli-ui//lib/cli/ui/ansi.rb#10
CLI::UI::ANSI::ESC = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/color.rb#7
class CLI::UI::Color
  # Creates a new color mapping
  # Signatures can be found here:
  # https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
  #
  # ==== Attributes
  #
  # * +sgr+ - The color signature
  # * +name+ - The name of the color
  #
  # source://cli-ui//lib/cli/ui/color.rb#26
  sig { params(sgr: ::String, name: ::Symbol).void }
  def initialize(sgr, name); end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/color.rb#11
  def code; end

  # source://cli-ui//lib/cli/ui/color.rb#14
  sig { returns(::Symbol) }
  def name; end

  # source://cli-ui//lib/cli/ui/color.rb#11
  sig { returns(::String) }
  def sgr; end

  class << self
    # All available colors by name
    #
    # source://cli-ui//lib/cli/ui/color.rb#97
    sig { returns(T::Array[::Symbol]) }
    def available; end

    # Looks up a color code by name
    #
    # ==== Raises
    # Raises a InvalidColorName if the color is not available
    # You likely need to add it to the +MAP+ or you made a typo
    #
    # ==== Returns
    # Returns a color code
    #
    # source://cli-ui//lib/cli/ui/color.rb#88
    sig { params(name: T.any(::String, ::Symbol)).returns(::CLI::UI::Color) }
    def lookup(name); end
  end
end

# default blue is low-contrast against black in some default terminal color scheme
#
# source://cli-ui//lib/cli/ui/color.rb#36
CLI::UI::Color::BLUE = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#40
CLI::UI::Color::BOLD = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#38
CLI::UI::Color::CYAN = T.let(T.unsafe(nil), CLI::UI::Color)

# 240 is very dark gray; 255 is very light gray. 244 is somewhat dark.
#
# source://cli-ui//lib/cli/ui/color.rb#44
CLI::UI::Color::GRAY = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#33
CLI::UI::Color::GREEN = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#58
class CLI::UI::Color::InvalidColorName < ::ArgumentError
  # source://cli-ui//lib/cli/ui/color.rb#62
  sig { params(name: ::Symbol).void }
  def initialize(name); end

  # source://cli-ui//lib/cli/ui/color.rb#68
  sig { returns(::String) }
  def message; end
end

# source://cli-ui//lib/cli/ui/color.rb#37
CLI::UI::Color::MAGENTA = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#46
CLI::UI::Color::MAP = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/color.rb#32
CLI::UI::Color::RED = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#39
CLI::UI::Color::RESET = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#41
CLI::UI::Color::WHITE = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#34
CLI::UI::Color::YELLOW = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui.rb#29
CLI::UI::Colorable = T.type_alias { T.any(::CLI::UI::Color, ::String, ::Symbol) }

# source://cli-ui//lib/cli/ui/formatter.rb#9
class CLI::UI::Formatter
  # Initialize a formatter with text.
  #
  # ===== Attributes
  #
  # * +text+ - the text to format
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#86
  sig { params(text: ::String).void }
  def initialize(text); end

  # Format the text using a map.
  #
  # ===== Attributes
  #
  # * +sgr_map+ - the mapping of the formattings. Defaults to +SGR_MAP+
  #
  # ===== Options
  #
  # * +:enable_color+ - enable color output? Default is true unless output is redirected
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#102
  sig { params(sgr_map: T::Hash[::String, ::String], enable_color: T::Boolean).returns(::String) }
  def format(sgr_map = T.unsafe(nil), enable_color: T.unsafe(nil)); end

  private

  # source://cli-ui//lib/cli/ui/formatter.rb#128
  sig do
    params(
      text: ::String,
      fmt: T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)],
      sgr_map: T::Hash[::String, ::String]
    ).returns(::String)
  end
  def apply_format(text, fmt, sgr_map); end

  # source://cli-ui//lib/cli/ui/formatter.rb#209
  sig { params(text: ::String, stack: T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)]).void }
  def emit(text, stack); end

  # source://cli-ui//lib/cli/ui/formatter.rb#189
  sig do
    params(
      sc: ::StringScanner,
      stack: T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)]
    ).returns(T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)])
  end
  def parse_body(sc, stack = T.unsafe(nil)); end

  # source://cli-ui//lib/cli/ui/formatter.rb#146
  sig do
    params(
      sc: ::StringScanner,
      stack: T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)]
    ).returns(T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)])
  end
  def parse_expr(sc, stack); end
end

# source://cli-ui//lib/cli/ui/formatter.rb#41
CLI::UI::Formatter::BEGIN_EXPR = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/formatter.rb#56
CLI::UI::Formatter::DISCARD_BRACES = T.let(T.unsafe(nil), Range)

# source://cli-ui//lib/cli/ui/formatter.rb#42
CLI::UI::Formatter::END_EXPR = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/formatter.rb#62
class CLI::UI::Formatter::FormatError < ::StandardError
  # source://cli-ui//lib/cli/ui/formatter.rb#72
  sig { params(message: ::String, input: ::String, index: ::Integer).void }
  def initialize(message, input, index); end

  # source://cli-ui//lib/cli/ui/formatter.rb#69
  sig { returns(::Integer) }
  def index; end

  # @return [Integer]
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#69
  def index=(_arg0); end

  # source://cli-ui//lib/cli/ui/formatter.rb#66
  sig { returns(::String) }
  def input; end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#66
  def input=(_arg0); end
end

# source://cli-ui//lib/cli/ui/formatter.rb#58
class CLI::UI::Formatter::LITERAL_BRACES; end

# source://cli-ui//lib/cli/ui/formatter.rb#47
CLI::UI::Formatter::SCAN_BODY = T.let(T.unsafe(nil), Regexp)

# source://cli-ui//lib/cli/ui/formatter.rb#45
CLI::UI::Formatter::SCAN_FUNCNAME = T.let(T.unsafe(nil), Regexp)

# source://cli-ui//lib/cli/ui/formatter.rb#46
CLI::UI::Formatter::SCAN_GLYPH = T.let(T.unsafe(nil), Regexp)

# source://cli-ui//lib/cli/ui/formatter.rb#44
CLI::UI::Formatter::SCAN_WIDGET = T.let(T.unsafe(nil), Regexp)

# Available mappings of formattings
# To use any of them, you can use {{<key>:<string>}}
# There are presentational (colours and formatters)
# and semantic (error, info, command) formatters available
#
# source://cli-ui//lib/cli/ui/formatter.rb#17
CLI::UI::Formatter::SGR_MAP = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/formatter.rb#60
CLI::UI::Formatter::Stack = T.type_alias { T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)] }

# source://cli-ui//lib/cli/ui/frame/frame_stack.rb#5
module CLI::UI::Frame
  class << self
    # Closes a frame
    # Automatically called for a block-form +open+
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - The color of the frame. Defaults to nil
    # * +:elapsed+ - How long did the frame take? Defaults to nil
    # * +frame_style+ - The frame style to use for this frame.  Defaults to nil
    #
    # ==== Example
    #
    #   CLI::UI::Frame.close('Close')
    #
    # Default Output:
    #   ┗━━ Close ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #
    # ==== Raises
    #
    # MUST be inside an open frame or it raises a +UnnestedFrameException+
    #
    # @raise [UnnestedFrameException]
    #
    # source://cli-ui//lib/cli/ui/frame.rb#215
    sig do
      params(
        text: T.nilable(::String),
        color: T.nilable(T.any(::CLI::UI::Color, ::String, ::Symbol)),
        elapsed: T.nilable(::Numeric),
        frame_style: T.nilable(T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol))
      ).void
    end
    def close(text, color: T.unsafe(nil), elapsed: T.unsafe(nil), frame_style: T.unsafe(nil)); end

    # Adds a divider in a frame
    # Used to separate information within a single frame
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - The color of the frame. Defaults to +DEFAULT_FRAME_COLOR+
    # * +frame_style+ - The frame style to use for this frame
    #
    # ==== Example
    #
    #   CLI::UI::Frame.open('Open') { CLI::UI::Frame.divider('Divider') }
    #
    # Default Output:
    #   ┏━━ Open ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #   ┣━━ Divider ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #
    # ==== Raises
    #
    # MUST be inside an open frame or it raises a +UnnestedFrameException+
    #
    # @raise [UnnestedFrameException]
    #
    # source://cli-ui//lib/cli/ui/frame.rb#168
    sig do
      params(
        text: T.nilable(::String),
        color: T.nilable(T.any(::CLI::UI::Color, ::String, ::Symbol)),
        frame_style: T.nilable(T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol))
      ).void
    end
    def divider(text, color: T.unsafe(nil), frame_style: T.unsafe(nil)); end

    # source://cli-ui//lib/cli/ui/frame.rb#19
    sig { returns(::CLI::UI::Frame::FrameStyle) }
    def frame_style; end

    # Set the default frame style.
    #
    # Raises ArgumentError if +frame_style+ is not valid
    #
    # ==== Attributes
    #
    # * +symbol+ or +FrameStyle+ - the default frame style to use for frames
    #
    # source://cli-ui//lib/cli/ui/frame.rb#32
    sig { params(frame_style: T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol)).void }
    def frame_style=(frame_style); end

    # Opens a new frame. Can be nested
    # Can be invoked in two ways: block and blockless
    # * In block form, the frame is closed automatically when the block returns
    # * In blockless form, caller MUST call +Frame.close+ when the frame is logically done
    # * Blockless form is strongly discouraged in cases where block form can be made to work
    #
    # https://user-images.githubusercontent.com/3074765/33799861-cb5dcb5c-dd01-11e7-977e-6fad38cee08c.png
    #
    # The return value of the block determines if the block is a "success" or a "failure"
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - The color of the frame. Defaults to +DEFAULT_FRAME_COLOR+
    # * +:failure_text+ - If the block failed, what do we output? Defaults to nil
    # * +:success_text+ - If the block succeeds, what do we output? Defaults to nil
    # * +:timing+ - How long did the frame content take? Invalid for blockless. Defaults to true for the block form
    # * +frame_style+ - The frame style to use for this frame
    #
    # ==== Example
    #
    # ===== Block Form (Assumes +CLI::UI::StdoutRouter.enable+ has been called)
    #
    #   CLI::UI::Frame.open('Open') { puts 'hi' }
    #
    # Default Output:
    #   ┏━━ Open ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #   ┃ hi
    #   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ (0.0s) ━━
    #
    # ===== Blockless Form
    #
    #   CLI::UI::Frame.open('Open')
    #
    # Default Output:
    #   ┏━━ Open ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #
    # source://cli-ui//lib/cli/ui/frame.rb#88
    sig do
      type_parameters(:T)
        .params(
          text: ::String,
          color: T.any(::CLI::UI::Color, ::String, ::Symbol),
          failure_text: T.nilable(::String),
          success_text: T.nilable(::String),
          timing: T.any(::Numeric, T::Boolean),
          frame_style: T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol),
          block: T.nilable(T.proc.returns(T.type_parameter(:T)))
        ).returns(T.nilable(T.type_parameter(:T)))
    end
    def open(text, color: T.unsafe(nil), failure_text: T.unsafe(nil), success_text: T.unsafe(nil), timing: T.unsafe(nil), frame_style: T.unsafe(nil), &block); end

    # Determines the prefix of a frame entry taking multi-nested frames into account
    #
    # ==== Options
    #
    # * +:color+ - The color of the prefix. Defaults to +Thread.current[:cliui_frame_color_override]+
    #
    # source://cli-ui//lib/cli/ui/frame.rb#236
    sig { params(color: T.nilable(T.any(::CLI::UI::Color, ::String, ::Symbol))).returns(::String) }
    def prefix(color: T.unsafe(nil)); end

    # The width of a prefix given the number of Frames in the stack
    #
    # source://cli-ui//lib/cli/ui/frame.rb#256
    sig { returns(::Integer) }
    def prefix_width; end

    # Override a color for a given thread.
    #
    # ==== Attributes
    #
    # * +color+ - The color to override to
    #
    # source://cli-ui//lib/cli/ui/frame.rb#275
    sig do
      type_parameters(:T)
        .params(
          color: T.any(::CLI::UI::Color, ::String, ::Symbol),
          block: T.proc.returns(T.type_parameter(:T))
        ).returns(T.type_parameter(:T))
    end
    def with_frame_color_override(color, &block); end

    private

    # If timing is:
    #   Numeric: return it
    #   false: return nil
    #   true: defaults to Time.new
    #
    # source://cli-ui//lib/cli/ui/frame.rb#290
    sig { params(start: ::Time, timing: T.any(::Numeric, T::Boolean)).returns(T.nilable(::Numeric)) }
    def elapsed(start, timing); end
  end
end

# source://cli-ui//lib/cli/ui/frame.rb#13
CLI::UI::Frame::DEFAULT_FRAME_COLOR = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/frame/frame_stack.rb#6
module CLI::UI::Frame::FrameStack
  class << self
    # Fetch all items off the frame stack
    #
    # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#34
    sig { returns(T::Array[::CLI::UI::Frame::FrameStack::StackItem]) }
    def items; end

    # Removes and returns the last stack item off the stack
    #
    # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#84
    sig { returns(T.nilable(::CLI::UI::Frame::FrameStack::StackItem)) }
    def pop; end

    # Push a new item onto the frame stack.
    #
    # Either an item or a :color/:style pair should be pushed onto the stack.
    #
    # ==== Attributes
    #
    # * +item+ a +StackItem+ to push onto the stack. Defaults to nil
    #
    # ==== Options
    #
    # * +:color+ the color of the new stack item. Defaults to nil
    # * +:style+ the style of the new stack item. Defaults to nil
    #
    # ==== Raises
    #
    # If both an item and a color/style pair are given, raises an +ArgumentError+
    # If the given item is not a +StackItem+, raises an +ArgumentError+
    #
    # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#69
    sig do
      params(
        item: T.nilable(::CLI::UI::Frame::FrameStack::StackItem),
        color: T.nilable(::CLI::UI::Color),
        style: T.nilable(::CLI::UI::Frame::FrameStyle)
      ).void
    end
    def push(item = T.unsafe(nil), color: T.unsafe(nil), style: T.unsafe(nil)); end

    private

    # Serializes the item stack into two ENV variables.
    #
    # This is done to preserve backward compatibility with earlier versions of cli/ui.
    # This ensures that any code that relied upon previous stack behavior should continue
    # to work.
    #
    # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#101
    sig { params(items: T::Array[::CLI::UI::Frame::FrameStack::StackItem]).void }
    def serialize(items); end
  end
end

# source://cli-ui//lib/cli/ui/frame/frame_stack.rb#7
CLI::UI::Frame::FrameStack::COLOR_ENVVAR = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_stack.rb#8
CLI::UI::Frame::FrameStack::STYLE_ENVVAR = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_stack.rb#10
class CLI::UI::Frame::FrameStack::StackItem
  # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#23
  sig do
    params(
      color_name: T.any(::CLI::UI::Color, ::String, ::Symbol),
      style_name: T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol)
    ).void
  end
  def initialize(color_name, style_name); end

  # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#14
  sig { returns(::CLI::UI::Color) }
  def color; end

  # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#17
  sig { returns(::CLI::UI::Frame::FrameStyle) }
  def frame_style; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://cli-ui//lib/cli/ui/frame/frame_style.rb#8
module CLI::UI::Frame::FrameStyle
  include ::Kernel

  abstract!

  # Draws the "Close" line for this frame style
  #
  # ==== Attributes
  #
  # * +text+ - (required) the text/title to output in the frame
  #
  # ==== Options
  #
  # * +:color+ - (required) The color of the frame.
  # * +:right_text+ - Text to print at the right of the line. Defaults to nil
  #
  # @abstract
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#77
  sig { abstract.params(text: ::String, color: ::CLI::UI::Color, right_text: T.nilable(::String)).returns(::String) }
  def close(text, color:, right_text: T.unsafe(nil)); end

  # Draws a "divider" line for the current frame style
  #
  # ==== Attributes
  #
  # * +text+ - (required) the text/title to output in the frame
  #
  # ==== Options
  #
  # * +:color+ - (required) The color of the frame.
  #
  # @abstract
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#90
  sig { abstract.params(text: ::String, color: ::CLI::UI::Color).returns(::String) }
  def divider(text, color:); end

  # Returns the character(s) that should be printed at the beginning
  # of lines inside this frame
  #
  # @abstract
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#44
  sig { abstract.returns(::String) }
  def prefix; end

  # Returns the printing width of the prefix
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#48
  sig { returns(::Integer) }
  def prefix_width; end

  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#93
  sig { params(x: ::Integer, str: ::String).returns(::String) }
  def print_at_x(x, str); end

  # Draws the "Open" line for this frame style
  #
  # ==== Attributes
  #
  # * +text+ - (required) the text/title to output in the frame
  #
  # ==== Options
  #
  # * +:color+ - (required) The color of the frame.
  #
  # @abstract
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#63
  sig { abstract.params(text: ::String, color: ::CLI::UI::Color).returns(::String) }
  def start(text, color:); end

  # @abstract
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#39
  sig { abstract.returns(::Symbol) }
  def style_name; end

  class << self
    # Lookup a frame style via its name
    #
    # ==== Attributes
    #
    # * +symbol+ - frame style name to lookup
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style.rb#31
    sig { params(name: T.any(::String, ::Symbol)).returns(::CLI::UI::Frame::FrameStyle) }
    def lookup(name); end
  end
end

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#7
module CLI::UI::Frame::FrameStyle::Box
  extend ::CLI::UI::Frame::FrameStyle

  class << self
    # Draws the "Close" line for this frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    # * +:right_text+ - Text to print at the right of the line. Defaults to nil
    #
    # ==== Output:
    #
    #   ┗━━ Close ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#83
    sig { override.params(text: ::String, color: ::CLI::UI::Color, right_text: T.nilable(::String)).returns(::String) }
    def close(text, color:, right_text: T.unsafe(nil)); end

    # Draws a "divider" line for the current frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    #
    # ==== Output:
    #
    #   ┣━━ Divider ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#63
    sig { override.params(text: ::String, color: ::CLI::UI::Color).returns(::String) }
    def divider(text, color:); end

    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#25
    sig { override.returns(::String) }
    def prefix; end

    # Draws the "Open" line for this frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    #
    # ==== Output:
    #
    #   ┏━━ Open ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#44
    sig { override.params(text: ::String, color: ::CLI::UI::Color).returns(::String) }
    def start(text, color:); end

    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#20
    sig { override.returns(::Symbol) }
    def style_name; end

    private

    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#92
    sig do
      params(
        text: ::String,
        color: ::CLI::UI::Color,
        first: ::String,
        right_text: T.nilable(::String)
      ).returns(::String)
    end
    def edge(text, color:, first:, right_text: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#14
CLI::UI::Frame::FrameStyle::Box::BOTTOM_LEFT = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#12
CLI::UI::Frame::FrameStyle::Box::DIVIDER = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#11
CLI::UI::Frame::FrameStyle::Box::HORIZONTAL = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#13
CLI::UI::Frame::FrameStyle::Box::TOP_LEFT = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#10
CLI::UI::Frame::FrameStyle::Box::VERTICAL = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#7
module CLI::UI::Frame::FrameStyle::Bracket
  extend ::CLI::UI::Frame::FrameStyle

  class << self
    # Draws the "Close" line for this frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    # * +:right_text+ - Text to print at the right of the line. Defaults to nil
    #
    # ==== Output:
    #
    #   ┗━━ Close
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#83
    sig { override.params(text: ::String, color: ::CLI::UI::Color, right_text: T.nilable(::String)).returns(::String) }
    def close(text, color:, right_text: T.unsafe(nil)); end

    # Draws a "divider" line for the current frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    #
    # ==== Output:
    #
    #   ┣━━ Divider
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#63
    sig { override.params(text: ::String, color: ::CLI::UI::Color).returns(::String) }
    def divider(text, color:); end

    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#25
    sig { override.returns(::String) }
    def prefix; end

    # Draws the "Open" line for this frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    #
    # ==== Output
    #
    #   ┏━━ Open
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#44
    sig { override.params(text: ::String, color: ::CLI::UI::Color).returns(::String) }
    def start(text, color:); end

    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#20
    sig { override.returns(::Symbol) }
    def style_name; end

    private

    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#92
    sig do
      params(
        text: ::String,
        color: ::CLI::UI::Color,
        first: ::String,
        right_text: T.nilable(::String)
      ).returns(::String)
    end
    def edge(text, color:, first:, right_text: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#14
CLI::UI::Frame::FrameStyle::Bracket::BOTTOM_LEFT = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#12
CLI::UI::Frame::FrameStyle::Bracket::DIVIDER = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#11
CLI::UI::Frame::FrameStyle::Bracket::HORIZONTAL = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#13
CLI::UI::Frame::FrameStyle::Bracket::TOP_LEFT = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#10
CLI::UI::Frame::FrameStyle::Bracket::VERTICAL = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style.rb#97
class CLI::UI::Frame::FrameStyle::InvalidFrameStyleName < ::ArgumentError
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#101
  sig { params(name: T.any(::String, ::Symbol)).void }
  def initialize(name); end

  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#107
  sig { returns(::String) }
  def message; end
end

# source://cli-ui//lib/cli/ui/frame/frame_style.rb#17
CLI::UI::Frame::FrameStyle::MAP = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/frame.rb#12
class CLI::UI::Frame::UnnestedFrameException < ::StandardError; end

# source://cli-ui//lib/cli/ui.rb#30
CLI::UI::FrameStylable = T.type_alias { T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol) }

# source://cli-ui//lib/cli/ui/glyph.rb#7
class CLI::UI::Glyph
  # Creates a new glyph
  #
  # ==== Attributes
  #
  # * +handle+ - The handle in the +MAP+ constant
  # * +codepoint+ - The codepoint used to create the glyph (e.g. +0x2717+ for a ballot X)
  # * +plain+ - A fallback plain string to be used in case glyphs are disabled
  # * +color+ - What color to output the glyph. Check +CLI::UI::Color+ for options.
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#46
  sig do
    params(
      handle: ::String,
      codepoint: T.any(::Integer, T::Array[::Integer]),
      plain: ::String,
      color: ::CLI::UI::Color
    ).void
  end
  def initialize(handle, codepoint, plain, color); end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#28
  def char; end

  # source://cli-ui//lib/cli/ui/glyph.rb#31
  sig { returns(T.any(::Integer, T::Array[::Integer])) }
  def codepoint; end

  # source://cli-ui//lib/cli/ui/glyph.rb#34
  sig { returns(::CLI::UI::Color) }
  def color; end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#28
  def fmt; end

  # source://cli-ui//lib/cli/ui/glyph.rb#28
  sig { returns(::String) }
  def handle; end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#28
  def to_s; end

  class << self
    # All available glyphs by name
    #
    # source://cli-ui//lib/cli/ui/glyph.rb#91
    sig { returns(T::Array[::String]) }
    def available; end

    # Looks up a glyph by name
    #
    # ==== Raises
    # Raises a InvalidGlyphHandle if the glyph is not available
    # You likely need to create it with +.new+ or you made a typo
    #
    # ==== Returns
    # Returns a terminal output-capable string
    #
    # source://cli-ui//lib/cli/ui/glyph.rb#82
    sig { params(name: ::String).returns(::CLI::UI::Glyph) }
    def lookup(name); end
  end
end

# Bug emoji (🐛)
#
# source://cli-ui//lib/cli/ui/glyph.rb#64
CLI::UI::Glyph::BUG = T.let(T.unsafe(nil), CLI::UI::Glyph)

# GREEN CHECK MARK (✓)
#
# source://cli-ui//lib/cli/ui/glyph.rb#62
CLI::UI::Glyph::CHECK = T.let(T.unsafe(nil), CLI::UI::Glyph)

# RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK (»)
#
# source://cli-ui//lib/cli/ui/glyph.rb#65
CLI::UI::Glyph::CHEVRON = T.let(T.unsafe(nil), CLI::UI::Glyph)

# HOURGLASS + VARIATION SELECTOR 15 (⌛︎)
#
# source://cli-ui//lib/cli/ui/glyph.rb#66
CLI::UI::Glyph::HOURGLASS = T.let(T.unsafe(nil), CLI::UI::Glyph)

# BLUE MATHEMATICAL SCRIPT SMALL i (𝒾)
#
# source://cli-ui//lib/cli/ui/glyph.rb#60
CLI::UI::Glyph::INFO = T.let(T.unsafe(nil), CLI::UI::Glyph)

# source://cli-ui//lib/cli/ui/glyph.rb#10
class CLI::UI::Glyph::InvalidGlyphHandle < ::ArgumentError
  # source://cli-ui//lib/cli/ui/glyph.rb#14
  sig { params(handle: ::String).void }
  def initialize(handle); end

  # source://cli-ui//lib/cli/ui/glyph.rb#20
  sig { returns(::String) }
  def message; end
end

# Mapping of glyphs to terminal output
#
# source://cli-ui//lib/cli/ui/glyph.rb#58
CLI::UI::Glyph::MAP = T.let(T.unsafe(nil), Hash)

# BLUE QUESTION MARK (?)
#
# source://cli-ui//lib/cli/ui/glyph.rb#61
CLI::UI::Glyph::QUESTION = T.let(T.unsafe(nil), CLI::UI::Glyph)

# YELLOW SMALL STAR (⭑)
#
# source://cli-ui//lib/cli/ui/glyph.rb#59
CLI::UI::Glyph::STAR = T.let(T.unsafe(nil), CLI::UI::Glyph)

# WARNING SIGN + VARIATION SELECTOR 16 (⚠️ )
#
# source://cli-ui//lib/cli/ui/glyph.rb#67
CLI::UI::Glyph::WARNING = T.let(T.unsafe(nil), CLI::UI::Glyph)

# RED BALLOT X (✗)
#
# source://cli-ui//lib/cli/ui/glyph.rb#63
CLI::UI::Glyph::X = T.let(T.unsafe(nil), CLI::UI::Glyph)

# source://cli-ui//lib/cli/ui.rb#31
CLI::UI::IOLike = T.type_alias { T.any(::IO, ::StringIO) }

# source://cli-ui//lib/cli/ui/os.rb#7
class CLI::UI::OS
  # source://cli-ui//lib/cli/ui/os.rb#11
  sig { params(emoji: T::Boolean, color_prompt: T::Boolean, arrow_keys: T::Boolean, shift_cursor: T::Boolean).void }
  def initialize(emoji: T.unsafe(nil), color_prompt: T.unsafe(nil), arrow_keys: T.unsafe(nil), shift_cursor: T.unsafe(nil)); end

  # source://cli-ui//lib/cli/ui/os.rb#34
  sig { returns(T::Boolean) }
  def shift_cursor_back_on_horizontal_absolute?; end

  # source://cli-ui//lib/cli/ui/os.rb#29
  sig { returns(T::Boolean) }
  def suggest_arrow_keys?; end

  # source://cli-ui//lib/cli/ui/os.rb#24
  sig { returns(T::Boolean) }
  def use_color_prompt?; end

  # source://cli-ui//lib/cli/ui/os.rb#19
  sig { returns(T::Boolean) }
  def use_emoji?; end

  class << self
    # source://cli-ui//lib/cli/ui/os.rb#42
    sig { returns(::CLI::UI::OS) }
    def current; end
  end
end

# source://cli-ui//lib/cli/ui/os.rb#59
CLI::UI::OS::LINUX = T.let(T.unsafe(nil), CLI::UI::OS)

# source://cli-ui//lib/cli/ui/os.rb#58
CLI::UI::OS::MAC = T.let(T.unsafe(nil), CLI::UI::OS)

# source://cli-ui//lib/cli/ui/os.rb#60
CLI::UI::OS::WINDOWS = T.let(T.unsafe(nil), CLI::UI::OS)

# source://cli-ui//lib/cli/ui/printer.rb#7
class CLI::UI::Printer
  class << self
    # Print a message to a stream with common utilities.
    # Allows overriding the color, encoding, and target stream.
    # By default, it formats the string using CLI:UI and rescues common stream errors.
    #
    # ==== Attributes
    #
    # * +msg+ - (required) the string to output. Can be frozen.
    #
    # ==== Options
    #
    # * +:frame_color+ - Override the frame color. Defaults to nil.
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with a puts method. Defaults to $stdout.
    # * +:encoding+ - Force the output to be in a certain encoding. Defaults to UTF-8.
    # * +:format+ - Whether to format the string using CLI::UI.fmt. Defaults to true.
    # * +:graceful+ - Whether to gracefully ignore common I/O errors. Defaults to true.
    # * +:wrap+ - Whether to wrap text at word boundaries to terminal width. Defaults to true.
    #
    # ==== Returns
    # Returns whether the message was successfully printed,
    # which can be useful if +:graceful+ is set to true.
    #
    # ==== Example
    #
    #   CLI::UI::Printer.puts('{{x}} Ouch', to: $stderr)
    #
    # source://cli-ui//lib/cli/ui/printer.rb#49
    sig do
      params(
        msg: ::String,
        frame_color: T.nilable(T.any(::CLI::UI::Color, ::String, ::Symbol)),
        to: T.any(::IO, ::StringIO),
        encoding: T.nilable(::Encoding),
        format: T::Boolean,
        graceful: T::Boolean,
        wrap: T::Boolean
      ).returns(T::Boolean)
    end
    def puts(msg, frame_color: T.unsafe(nil), to: T.unsafe(nil), encoding: T.unsafe(nil), format: T.unsafe(nil), graceful: T.unsafe(nil), wrap: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/progress.rb#7
class CLI::UI::Progress
  # Initialize a progress bar. Typically used in a +Progress.progress+ block
  #
  # ==== Options
  # One of the follow can be used, but not both together
  #
  # * +:width+ - The width of the terminal
  #
  # source://cli-ui//lib/cli/ui/progress.rb#63
  sig { params(width: ::Integer).void }
  def initialize(width: T.unsafe(nil)); end

  # Set the progress of the bar. Typically used in a +Progress.progress+ block
  #
  # ==== Options
  # One of the follow can be used, but not both together
  #
  # * +:percent+ - Increment progress by a specific percent amount
  # * +:set_percent+ - Set progress to a specific percent
  #
  # *Note:* The +:percent+ and +:set_percent must be between 0.00 and 1.0
  #
  # @raise [ArgumentError]
  #
  # source://cli-ui//lib/cli/ui/progress.rb#79
  sig { params(percent: T.nilable(::Numeric), set_percent: T.nilable(::Numeric)).void }
  def tick(percent: T.unsafe(nil), set_percent: T.unsafe(nil)); end

  # Format the progress bar to be printed to terminal
  #
  # source://cli-ui//lib/cli/ui/progress.rb#93
  sig { returns(::String) }
  def to_s; end

  class << self
    # Add a progress bar to the terminal output
    #
    # https://user-images.githubusercontent.com/3074765/33799794-cc4c940e-dd00-11e7-9bdc-90f77ec9167c.gif
    #
    # ==== Example Usage:
    #
    # Set the percent to X
    #   CLI::UI::Progress.progress do |bar|
    #     bar.tick(set_percent: percent)
    #   end
    #
    # Increase the percent by 1 percent
    #   CLI::UI::Progress.progress do |bar|
    #     bar.tick
    #   end
    #
    # Increase the percent by X
    #   CLI::UI::Progress.progress do |bar|
    #     bar.tick(percent: 0.05)
    #   end
    #
    # source://cli-ui//lib/cli/ui/progress.rb#43
    sig do
      type_parameters(:T)
        .params(
          width: ::Integer,
          block: T.proc.params(bar: ::CLI::UI::Progress).returns(T.type_parameter(:T))
        ).returns(T.type_parameter(:T))
    end
    def progress(width: T.unsafe(nil), &block); end
  end
end

# A Cyan filled block
#
# source://cli-ui//lib/cli/ui/progress.rb#11
CLI::UI::Progress::FILLED_BAR = T.let(T.unsafe(nil), String)

# A bright white block
#
# source://cli-ui//lib/cli/ui/progress.rb#13
CLI::UI::Progress::UNFILLED_BAR = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt.rb#25
module CLI::UI::Prompt
  class << self
    # Ask a user a question with either free form answer or a set of answers (multiple choice)
    # Can use arrows, y/n, numbers (1/2), and vim bindings to control multiple choice selection
    # Do not use this method for yes/no questions. Use +confirm+
    #
    # * Handles free form answers (options are nil)
    # * Handles default answers for free form text
    # * Handles file auto completion for file input
    # * Handles interactively choosing answers using +InteractiveOptions+
    #
    # https://user-images.githubusercontent.com/3074765/33799822-47f23302-dd01-11e7-82f3-9072a5a5f611.png
    #
    # ==== Attributes
    #
    # * +question+ - (required) The question to ask the user
    #
    # ==== Options
    #
    # * +:options+ - Options that the user may select from. Will use +InteractiveOptions+ to do so.
    # * +:default+ - The default answer to the question (e.g. they just press enter and don't input anything)
    # * +:is_file+ - Tells the input to use file auto-completion (tab completion)
    # * +:allow_empty+ - Allows the answer to be empty
    # * +:multiple+ - Allow multiple options to be selected
    # * +:filter_ui+ - Enable option filtering (default: true)
    # * +:select_ui+ - Enable long-form option selection (default: true)
    #
    # Note:
    # * +:options+ or providing a +Block+ conflicts with +:default+ and +:is_file+,
    #              you cannot set options with either of these keywords
    # * +:default+ conflicts with +:allow_empty:, you cannot set these together
    # * +:options+ conflicts with providing a +Block+ , you may only set one
    # * +:multiple+ can only be used with +:options+ or a +Block+; it is ignored, otherwise.
    #
    # ==== Block (optional)
    #
    # * A Proc that provides a +OptionsHandler+ and uses the public +:option+ method to add options and their
    #   respective handlers
    #
    # ==== Return Value
    #
    # * If a +Block+ was not provided, the selected option or response to the free form question will be returned
    # * If a +Block+ was provided, the evaluated value of the +Block+ will be returned
    #
    # ==== Example Usage:
    #
    # Free form question
    #   CLI::UI::Prompt.ask('What color is the sky?')
    #
    # Free form question with a file answer
    #   CLI::UI::Prompt.ask('Where is your Gemfile located?', is_file: true)
    #
    # Free form question with a default answer
    #   CLI::UI::Prompt.ask('What color is the sky?', default: 'blue')
    #
    # Free form question when the answer can be empty
    #   CLI::UI::Prompt.ask('What is your opinion on this question?', allow_empty: true)
    #
    # Interactive (multiple choice) question
    #   CLI::UI::Prompt.ask('What kind of project is this?', options: %w(rails go ruby python))
    #
    # Interactive (multiple choice) question with defined handlers
    #   CLI::UI::Prompt.ask('What kind of project is this?') do |handler|
    #     handler.option('rails')  { |selection| selection }
    #     handler.option('go')     { |selection| selection }
    #     handler.option('ruby')   { |selection| selection }
    #     handler.option('python') { |selection| selection }
    #   end
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#112
    sig do
      params(
        question: ::String,
        options: T.nilable(T::Array[::String]),
        default: T.nilable(T.any(::String, T::Array[::String])),
        is_file: T::Boolean,
        allow_empty: T::Boolean,
        multiple: T::Boolean,
        filter_ui: T::Boolean,
        select_ui: T::Boolean,
        options_proc: T.nilable(T.proc.params(handler: ::CLI::UI::Prompt::OptionsHandler).void)
      ).returns(T.any(::String, T::Array[::String]))
    end
    def ask(question, options: T.unsafe(nil), default: T.unsafe(nil), is_file: T.unsafe(nil), allow_empty: T.unsafe(nil), multiple: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil), &options_proc); end

    # Asks the user for a single-line answer, without displaying the characters while typing.
    # Typically used for password prompts
    #
    # ==== Return Value
    #
    # The password, without a trailing newline.
    # If the user simply presses "Enter" without typing any password, this will return an empty string.
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#167
    sig { params(question: ::String).returns(::String) }
    def ask_password(question); end

    # Asks the user a yes/no question.
    # Can use arrows, y/n, numbers (1/2), and vim bindings to control
    #
    # ==== Example Usage:
    #
    # Confirmation question
    #   CLI::UI::Prompt.confirm('Is the sky blue?')
    #
    #   CLI::UI::Prompt.confirm('Do a dangerous thing?', default: false)
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#196
    sig { params(question: ::String, default: T::Boolean).returns(T::Boolean) }
    def confirm(question, default: T.unsafe(nil)); end

    private

    # source://cli-ui//lib/cli/ui/prompt.rb#206
    sig do
      params(
        question: ::String,
        default: T.nilable(::String),
        is_file: T::Boolean,
        allow_empty: T::Boolean
      ).returns(::String)
    end
    def ask_free_form(question, default, is_file, allow_empty); end

    # @raise [ArgumentError]
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#242
    sig do
      params(
        question: ::String,
        options: T.nilable(T::Array[::String]),
        multiple: T::Boolean,
        default: T.nilable(T.any(::String, T::Array[::String])),
        filter_ui: T::Boolean,
        select_ui: T::Boolean
      ).returns(T.any(::String, T::Array[::String]))
    end
    def ask_interactive(question, options = T.unsafe(nil), multiple: T.unsafe(nil), default: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil)); end

    # Useful for stubbing in tests
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#296
    sig do
      params(
        options: T::Array[::String],
        multiple: T::Boolean,
        default: T.nilable(T.any(::String, T::Array[::String]))
      ).returns(T.any(::String, T::Array[::String]))
    end
    def interactive_prompt(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end

    # source://cli-ui//lib/cli/ui/prompt.rb#314
    sig { params(str: ::String).void }
    def puts_question(str); end

    # source://cli-ui//lib/cli/ui/prompt.rb#319
    sig { params(is_file: T::Boolean).returns(::String) }
    def readline(is_file: T.unsafe(nil)); end

    # source://cli-ui//lib/cli/ui/prompt.rb#301
    sig { params(default: ::String).void }
    def write_default_over_empty_input(default); end
  end
end

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#10
class CLI::UI::Prompt::InteractiveOptions
  # Initializes a new +InteractiveOptions+
  # Usually called from +self.call+
  #
  # ==== Example Usage:
  #
  #   CLI::UI::Prompt::InteractiveOptions.new(%w(rails go python))
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#60
  sig do
    params(
      options: T::Array[::String],
      multiple: T::Boolean,
      default: T.nilable(T.any(::String, T::Array[::String]))
    ).void
  end
  def initialize(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end

  # Calls the +InteractiveOptions+ and asks the question
  # Usually used from +self.call+
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#88
  sig { returns(T.any(::Integer, T::Array[::Integer])) }
  def call; end

  private

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#242
  sig { params(char: ::String).void }
  def build_selection(char); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#108
  sig { void }
  def calculate_option_line_lengths; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#248
  sig { void }
  def chop_selection; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#142
  sig { params(number_of_lines: ::Integer).void }
  def clear_output(number_of_lines = T.unsafe(nil)); end

  # Don't use this in place of +@displaying_metadata+, this updates too
  # quickly to be useful when drawing to the screen.
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#158
  sig { returns(T::Boolean) }
  def display_metadata?; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#440
  sig { returns(::Integer) }
  def distance_from_selection_to_end; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#445
  sig { returns(::Integer) }
  def distance_from_start_to_selection; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#198
  sig { void }
  def down; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#460
  sig { void }
  def ensure_first_item_is_continuation_marker; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#455
  sig { void }
  def ensure_last_item_is_continuation_marker; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#433
  sig { void }
  def ensure_visible_is_active; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#349
  sig { returns(T::Boolean) }
  def filtering?; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#519
  sig { params(format: ::String, choice: ::String).returns(::String) }
  def format_choice(format, choice); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#354
  sig { returns(T::Boolean) }
  def has_filter?; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#450
  sig { returns(::Integer) }
  def index_of_active_option; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#465
  sig { returns(::Integer) }
  def max_lines; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#163
  sig { returns(::Integer) }
  def num_lines; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#390
  sig { params(recalculate: T::Boolean).returns(T::Array[[::String, T.nilable(::Integer)]]) }
  def presented_options(recalculate: T.unsafe(nil)); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#280
  sig { void }
  def process_input_until_redraw_required; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#379
  sig { returns(T.nilable(::String)) }
  def read_char; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#470
  sig { void }
  def render_options; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#133
  sig { params(number_of_lines: ::Integer).void }
  def reset_position(number_of_lines = T.unsafe(nil)); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#232
  sig { params(char: ::String).void }
  def select_bool(char); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#272
  sig { void }
  def select_current; end

  # n is 1-indexed selection
  # n == 0 if "Done" was selected in @multiple mode
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#211
  sig { params(n: ::Integer).void }
  def select_n(n); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#344
  sig { returns(T::Boolean) }
  def selecting?; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#359
  sig { void }
  def start_filter; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#365
  sig { void }
  def start_line_select; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#372
  sig { void }
  def stop_line_select; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#177
  sig { returns(T::Boolean) }
  def terminal_width_changed?; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#187
  sig { void }
  def up; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#254
  sig { params(char: ::String).void }
  def update_search(char); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#287
  sig { void }
  def wait_for_user_input; end

  class << self
    # Prompts the user with options
    # Uses an interactive session to allow the user to pick an answer
    # Can use arrows, y/n, numbers (1/2), and vim bindings to control
    # For more than 9 options, hitting 'e', ':', or 'G' will enter select
    # mode allowing the user to type in longer numbers
    # Pressing 'f' or '/' will allow the user to filter the results
    #
    # https://user-images.githubusercontent.com/3074765/33797984-0ebb5e64-dcdf-11e7-9e7e-7204f279cece.gif
    #
    # ==== Example Usage:
    #
    # Ask an interactive question
    #   CLI::UI::Prompt::InteractiveOptions.call(%w(rails go python))
    #
    # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#37
    sig do
      params(
        options: T::Array[::String],
        multiple: T::Boolean,
        default: T.nilable(T.any(::String, T::Array[::String]))
      ).returns(T.any(::String, T::Array[::String]))
    end
    def call(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#182
CLI::UI::Prompt::InteractiveOptions::BACKSPACE = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#14
CLI::UI::Prompt::InteractiveOptions::CHECKBOX_ICON = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#183
CLI::UI::Prompt::InteractiveOptions::CTRL_C = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#184
CLI::UI::Prompt::InteractiveOptions::CTRL_D = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#13
CLI::UI::Prompt::InteractiveOptions::DONE = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#181
CLI::UI::Prompt::InteractiveOptions::ESC = T.let(T.unsafe(nil), String)

# A class that handles the various options of an InteractivePrompt and their callbacks
#
# source://cli-ui//lib/cli/ui/prompt/options_handler.rb#7
class CLI::UI::Prompt::OptionsHandler
  # source://cli-ui//lib/cli/ui/prompt/options_handler.rb#11
  sig { void }
  def initialize; end

  # source://cli-ui//lib/cli/ui/prompt/options_handler.rb#26
  sig { params(options: T.any(::String, T::Array[::String])).returns(::String) }
  def call(options); end

  # source://cli-ui//lib/cli/ui/prompt/options_handler.rb#21
  sig { params(option: ::String, handler: T.proc.params(option: ::String).returns(::String)).void }
  def option(option, &handler); end

  # source://cli-ui//lib/cli/ui/prompt/options_handler.rb#16
  sig { returns(T::Array[::String]) }
  def options; end
end

# Convenience accessor to +CLI::UI::Spinner::SpinGroup+
#
# source://cli-ui//lib/cli/ui.rb#27
CLI::UI::SpinGroup = CLI::UI::Spinner::SpinGroup

# source://cli-ui//lib/cli/ui/spinner.rb#8
module CLI::UI::Spinner
  class << self
    # We use this from CLI::UI::Widgets::Status to render an additional
    # spinner next to the "working" element. While this global state looks
    # a bit repulsive at first, it's worth realizing that:
    #
    # * It's managed by the SpinGroup#wait method, not individual tasks; and
    # * It would be complete insanity to run two separate but concurrent SpinGroups.
    #
    # While it would be possible to stitch through some connection between
    # the SpinGroup and the Widgets included in its title, this is simpler
    # in practice and seems unlikely to cause issues in practice.
    #
    # source://cli-ui//lib/cli/ui/spinner.rb#44
    sig { returns(::String) }
    def current_rune; end

    # source://cli-ui//lib/cli/ui/spinner.rb#31
    sig { returns(T.nilable(::Integer)) }
    def index; end

    # @return [Integer, nil]
    #
    # source://cli-ui//lib/cli/ui/spinner.rb#31
    def index=(_arg0); end

    # Adds a single spinner
    # Uses an interactive session to allow the user to pick an answer
    # Can use arrows, y/n, numbers (1/2), and vim bindings to control
    #
    # https://user-images.githubusercontent.com/3074765/33798295-d94fd822-dce3-11e7-819b-43e5502d490e.gif
    #
    # ==== Attributes
    #
    # * +title+ - Title of the spinner to use
    #
    # ==== Options
    #
    # * +:auto_debrief+ - Automatically debrief exceptions or through success_debrief? Default to true
    #
    # ==== Block
    #
    # * *spinner+ - Instance of the spinner. Can call +update_title+ to update the user of changes
    #
    # ==== Example Usage:
    #
    #   CLI::UI::Spinner.spin('Title') { sleep 1.0 }
    #
    # source://cli-ui//lib/cli/ui/spinner.rb#78
    sig do
      params(
        title: ::String,
        auto_debrief: T::Boolean,
        block: T.proc.params(task: ::CLI::UI::Spinner::SpinGroup::Task).void
      ).returns(T::Boolean)
    end
    def spin(title, auto_debrief: T.unsafe(nil), &block); end
  end
end

# source://cli-ui//lib/cli/ui/spinner/async.rb#6
class CLI::UI::Spinner::Async
  # Initializes a new asynchronous spinner with no specific end.
  # Must call +.stop+ to end the spinner
  #
  # ==== Attributes
  #
  # * +title+ - Title of the spinner to use
  #
  # ==== Example Usage:
  #
  #   CLI::UI::Spinner::Async.new('Title')
  #
  # source://cli-ui//lib/cli/ui/spinner/async.rb#32
  sig { params(title: ::String).void }
  def initialize(title); end

  # Stops an asynchronous spinner
  #
  # source://cli-ui//lib/cli/ui/spinner/async.rb#44
  sig { returns(T::Boolean) }
  def stop; end

  class << self
    # Convenience method for +initialize+
    #
    # source://cli-ui//lib/cli/ui/spinner/async.rb#15
    sig { params(title: ::String).returns(::CLI::UI::Spinner::Async) }
    def start(title); end
  end
end

# source://cli-ui//lib/cli/ui/spinner.rb#25
CLI::UI::Spinner::GLYPHS = T.let(T.unsafe(nil), Array)

# seconds
#
# source://cli-ui//lib/cli/ui/spinner.rb#14
CLI::UI::Spinner::PERIOD = T.let(T.unsafe(nil), Float)

# source://cli-ui//lib/cli/ui/spinner.rb#17
CLI::UI::Spinner::RUNES = T.let(T.unsafe(nil), Array)

# source://cli-ui//lib/cli/ui/spinner/spin_group.rb#6
class CLI::UI::Spinner::SpinGroup
  # Initializes a new spin group
  # This lets you add +Task+ objects to the group to multi-thread work
  #
  # ==== Options
  #
  # * +:auto_debrief+ - Automatically debrief exceptions or through success_debrief? Default to true
  #
  # ==== Example Usage
  #
  #  CLI::UI::SpinGroup.new do |spin_group|
  #    spin_group.add('Title')   { |spinner| sleep 3.0 }
  #    spin_group.add('Title 2') { |spinner| sleep 3.0; spinner.update_title('New Title'); sleep 3.0 }
  #  end
  #
  # Output:
  #
  # https://user-images.githubusercontent.com/3074765/33798558-c452fa26-dce8-11e7-9e90-b4b34df21a46.gif
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#28
  sig { params(auto_debrief: T::Boolean).void }
  def initialize(auto_debrief: T.unsafe(nil)); end

  # Add a new task
  #
  # ==== Attributes
  #
  # * +title+ - Title of the task
  # * +block+ - Block for the task, will be provided with an instance of the spinner
  #
  # ==== Example Usage:
  #   spin_group = CLI::UI::SpinGroup.new
  #   spin_group.add('Title') { |spinner| sleep 1.0 }
  #   spin_group.wait
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#206
  sig { params(title: ::String, block: T.proc.params(task: ::CLI::UI::Spinner::SpinGroup::Task).void).void }
  def add(title, &block); end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#287
  sig { returns(T::Boolean) }
  def all_succeeded?; end

  # Debriefs failed tasks is +auto_debrief+ is true
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#296
  sig { returns(T::Boolean) }
  def debrief; end

  # Provide an alternative debriefing for failed tasks
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#272
  sig do
    params(
      block: T.proc.params(title: ::String, exception: T.nilable(::Exception), out: ::String, err: ::String).void
    ).void
  end
  def failure_debrief(&block); end

  # Provide a debriefing for successful tasks
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#282
  sig { params(block: T.proc.params(title: ::String, out: ::String, err: ::String).void).void }
  def success_debrief(&block); end

  # Tells the group you're done adding tasks and to wait for all of them to finish
  #
  # ==== Example Usage:
  #   spin_group = CLI::UI::SpinGroup.new
  #   spin_group.add('Title') { |spinner| sleep 1.0 }
  #   spin_group.wait
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#220
  sig { returns(T::Boolean) }
  def wait; end
end

# source://cli-ui//lib/cli/ui/spinner/spin_group.rb#40
class CLI::UI::Spinner::SpinGroup::Task
  # Initializes a new Task
  # This is managed entirely internally by +SpinGroup+
  #
  # ==== Attributes
  #
  # * +title+ - Title of the task
  # * +block+ - Block for the task, will be provided with an instance of the spinner
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#61
  sig do
    params(
      title: ::String,
      block: T.proc.params(task: ::CLI::UI::Spinner::SpinGroup::Task).returns(T.untyped)
    ).void
  end
  def initialize(title, &block); end

  # Checks if a task is finished
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#84
  sig { returns(T::Boolean) }
  def check; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#50
  sig { returns(T.nilable(::Exception)) }
  def exception; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#148
  sig { void }
  def interrupt; end

  # Re-renders the task if required:
  #
  # We try to be as lazy as possible in re-rendering the full line. The
  # spinner rune will change on each render for the most part, but the
  # body text will rarely have changed. If the body text *has* changed,
  # we set @force_full_render.
  #
  # Further, if the title string includes any CLI::UI::Widgets, we
  # assume that it may change from render to render, since those
  # evaluate more dynamically than the rest of our format codes, which
  # are just text formatters. This is controlled by @always_full_render.
  #
  # ==== Attributes
  #
  # * +index+ - index of the task
  # * +force+ - force rerender of the task
  # * +width+ - current terminal width to format for
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#120
  sig { params(index: ::Integer, force: T::Boolean, width: ::Integer).returns(::String) }
  def render(index, force = T.unsafe(nil), width: T.unsafe(nil)); end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#44
  def stderr; end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#44
  def stdout; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#47
  sig { returns(T::Boolean) }
  def success; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#44
  sig { returns(::String) }
  def title; end

  # Update the spinner title
  #
  # ==== Attributes
  #
  # * +title+ - title to change the spinner to
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#139
  sig { params(new_title: ::String).void }
  def update_title(new_title); end

  private

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#155
  sig { params(index: ::Integer, terminal_width: ::Integer).returns(::String) }
  def full_render(index, terminal_width); end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#174
  sig { params(index: ::Integer).returns(::String) }
  def glyph(index); end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#183
  sig { returns(::String) }
  def inset; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#188
  sig { returns(::Integer) }
  def inset_width; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#169
  sig { params(index: ::Integer).returns(::String) }
  def partial_render(index); end
end

# source://cli-ui//lib/cli/ui/spinner.rb#15
CLI::UI::Spinner::TASK_FAILED = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/stdout_router.rb#8
module CLI::UI::StdoutRouter
  class << self
    # @raise [NotEnabled]
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#205
    sig { void }
    def assert_enabled!; end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#200
    sig { returns(T.nilable(T::Hash[::Symbol, T.any(::IO, ::String, ::StringIO)])) }
    def current_id; end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#238
    sig { returns(T::Boolean) }
    def disable; end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#180
    sig { returns(T.nilable(T.any(::IO, ::StringIO))) }
    def duplicate_output_to; end

    # @return [IOLike, nil]
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#180
    def duplicate_output_to=(_arg0); end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#224
    sig { returns(T::Boolean) }
    def enable; end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#233
    sig { params(stream: T.any(::IO, ::StringIO)).returns(T::Boolean) }
    def enabled?(stream = T.unsafe(nil)); end

    # TODO: remove this
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#219
    sig { void }
    def ensure_activated; end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#210
    sig { type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T)) }
    def with_enabled(&block); end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#187
    sig do
      type_parameters(:T)
        .params(
          on_streams: T::Array[T.any(::IO, ::StringIO)],
          block: T.proc.params(id: ::String).returns(T.type_parameter(:T))
        ).returns(T.type_parameter(:T))
    end
    def with_id(on_streams:, &block); end

    private

    # source://cli-ui//lib/cli/ui/stdout_router.rb#256
    sig { params(stream: T.any(::IO, ::StringIO), streamname: ::Symbol).void }
    def activate(stream, streamname); end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#249
    sig { params(stream: T.any(::IO, ::StringIO)).void }
    def deactivate(stream); end
  end
end

# source://cli-ui//lib/cli/ui/stdout_router.rb#86
class CLI::UI::StdoutRouter::Capture
  # source://cli-ui//lib/cli/ui/stdout_router.rb#122
  sig { params(with_frame_inset: T::Boolean, block: T.proc.void).void }
  def initialize(with_frame_inset: T.unsafe(nil), &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#133
  sig { returns(T.untyped) }
  def run; end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#130
  def stderr; end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#130
  sig { returns(::String) }
  def stdout; end

  class << self
    # source://cli-ui//lib/cli/ui/stdout_router.rb#97
    sig { type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T)) }
    def with_stdin_masked(&block); end
  end
end

# source://cli-ui//lib/cli/ui/stdout_router.rb#9
class CLI::UI::StdoutRouter::Writer
  # source://cli-ui//lib/cli/ui/stdout_router.rb#13
  sig { params(stream: T.any(::IO, ::StringIO), name: ::Symbol).void }
  def initialize(stream, name); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#19
  sig { params(args: ::String).void }
  def write(*args); end

  private

  # source://cli-ui//lib/cli/ui/stdout_router.rb#69
  sig { params(str: ::String, prefix: ::String).returns(::String) }
  def apply_line_prefix(str, prefix); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#64
  sig { returns(T::Boolean) }
  def auto_frame_inset?; end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#45
  sig { params(stream: T.any(::IO, ::StringIO), args: T::Array[::String]).returns(T::Array[::String]) }
  def prepend_id(stream, args); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#56
  sig { params(stream: T.any(::IO, ::StringIO)).returns(T::Boolean) }
  def prepend_id_for_stream(stream); end
end

# source://cli-ui//lib/cli/ui/terminal.rb#8
module CLI::UI::Terminal
  class << self
    # Returns the width of the terminal, if possible
    # Otherwise, will return DEFAULT_HEIGHT
    #
    # source://cli-ui//lib/cli/ui/terminal.rb#29
    sig { returns(::Integer) }
    def height; end

    # source://cli-ui//lib/cli/ui/terminal.rb#50
    sig { void }
    def setup_winsize_trap; end

    # Returns the width of the terminal, if possible
    # Otherwise will return DEFAULT_WIDTH
    #
    # source://cli-ui//lib/cli/ui/terminal.rb#21
    sig { returns(::Integer) }
    def width; end

    # source://cli-ui//lib/cli/ui/terminal.rb#34
    sig { returns([::Integer, ::Integer]) }
    def winsize; end
  end
end

# source://cli-ui//lib/cli/ui/terminal.rb#12
CLI::UI::Terminal::DEFAULT_HEIGHT = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/terminal.rb#11
CLI::UI::Terminal::DEFAULT_WIDTH = T.let(T.unsafe(nil), Integer)

# Truncater truncates a string to a provided printable width.
#
# source://cli-ui//lib/cli/ui/truncater.rb#9
module CLI::UI::Truncater
  class << self
    # source://cli-ui//lib/cli/ui/truncater.rb#34
    sig { params(text: ::String, printing_width: ::Integer).returns(::String) }
    def call(text, printing_width); end

    private

    # source://cli-ui//lib/cli/ui/truncater.rb#96
    sig { params(printable_codepoint: ::Integer).returns(::Integer) }
    def width(printable_codepoint); end
  end
end

# EMOJI_RANGE in particular is super inaccurate. This is best-effort.
# If you need this to be more accurate, we'll almost certainly accept a
# PR improving it.
#
# source://cli-ui//lib/cli/ui/truncater.rb#23
CLI::UI::Truncater::EMOJI_RANGE = T.let(T.unsafe(nil), Range)

# source://cli-ui//lib/cli/ui/truncater.rb#15
CLI::UI::Truncater::ESC = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/truncater.rb#25
CLI::UI::Truncater::LC_ALPHA_RANGE = T.let(T.unsafe(nil), Range)

# source://cli-ui//lib/cli/ui/truncater.rb#16
CLI::UI::Truncater::LEFT_SQUARE_BRACKET = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/truncater.rb#24
CLI::UI::Truncater::NUMERIC_RANGE = T.let(T.unsafe(nil), Range)

# source://cli-ui//lib/cli/ui/truncater.rb#11
CLI::UI::Truncater::PARSE_ANSI = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/truncater.rb#12
CLI::UI::Truncater::PARSE_ESC = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/truncater.rb#10
CLI::UI::Truncater::PARSE_ROOT = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/truncater.rb#13
CLI::UI::Truncater::PARSE_ZWJ = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/truncater.rb#18
CLI::UI::Truncater::SEMICOLON = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/truncater.rb#28
CLI::UI::Truncater::TRUNCATED = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/truncater.rb#26
CLI::UI::Truncater::UC_ALPHA_RANGE = T.let(T.unsafe(nil), Range)

# emojipedia.org/emoji-zwj-sequences
#
# source://cli-ui//lib/cli/ui/truncater.rb#17
CLI::UI::Truncater::ZWJ = T.let(T.unsafe(nil), Integer)

# Widgets are formatter objects with more custom implementations than the
# other features, which all center around formatting text with colours,
# etc.
#
# If you want to extend CLI::UI with your own widgets, you may want to do
# something like this:
#
#   require('cli/ui')
#   class MyWidget < CLI::UI::Widgets::Base
#     # ...
#   end
#   CLI::UI::Widgets.register('my-widget') { MyWidget }
#   puts(CLI::UI.fmt("{{@widget/my-widget:args}}"))
#
# source://cli-ui//lib/cli/ui/widgets.rb#20
module CLI::UI::Widgets
  class << self
    # All available widgets by name
    #
    # source://cli-ui//lib/cli/ui/widgets.rb#54
    sig { returns(T::Array[::String]) }
    def available; end

    # Looks up a widget by handle
    #
    # ==== Raises
    # Raises InvalidWidgetHandle if the widget is not available.
    #
    # ==== Returns
    # A callable widget, to be invoked like `.call(argstring)`
    #
    # source://cli-ui//lib/cli/ui/widgets.rb#45
    sig { params(handle: ::String).returns(T.class_of(CLI::UI::Widgets::Base)) }
    def lookup(handle); end

    # source://cli-ui//lib/cli/ui/widgets.rb#32
    sig { params(name: ::String, cb: T.proc.returns(T.class_of(CLI::UI::Widgets::Base))).void }
    def register(name, &cb); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://cli-ui//lib/cli/ui/widgets/base.rb#8
class CLI::UI::Widgets::Base
  abstract!

  # source://cli-ui//lib/cli/ui/widgets/base.rb#23
  sig { params(argstring: ::String).void }
  def initialize(argstring); end

  # @abstract
  #
  # source://cli-ui//lib/cli/ui/widgets/base.rb#42
  sig { abstract.returns(::String) }
  def render; end

  class << self
    # @abstract
    #
    # source://cli-ui//lib/cli/ui/widgets/base.rb#38
    sig { abstract.returns(::Regexp) }
    def argparse_pattern; end

    # source://cli-ui//lib/cli/ui/widgets/base.rb#17
    sig { params(argstring: ::String).returns(::String) }
    def call(argstring); end
  end
end

# source://cli-ui//lib/cli/ui/widgets.rb#78
class CLI::UI::Widgets::InvalidWidgetArguments < ::ArgumentError
  # source://cli-ui//lib/cli/ui/widgets.rb#82
  sig { params(argstring: ::String, pattern: ::Regexp).void }
  def initialize(argstring, pattern); end

  # source://cli-ui//lib/cli/ui/widgets.rb#89
  sig { returns(::String) }
  def message; end
end

# source://cli-ui//lib/cli/ui/widgets.rb#61
class CLI::UI::Widgets::InvalidWidgetHandle < ::ArgumentError
  # source://cli-ui//lib/cli/ui/widgets.rb#65
  sig { params(handle: ::String).void }
  def initialize(handle); end

  # source://cli-ui//lib/cli/ui/widgets.rb#71
  sig { returns(::String) }
  def message; end
end

# source://cli-ui//lib/cli/ui/widgets.rb#23
CLI::UI::Widgets::MAP = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/widgets/status.rb#9
class CLI::UI::Widgets::Status < ::CLI::UI::Widgets::Base
  # source://cli-ui//lib/cli/ui/widgets/status.rb#34
  sig { override.returns(::String) }
  def render; end

  private

  # source://cli-ui//lib/cli/ui/widgets/status.rb#51
  sig { params(num_str: ::String, rune: ::String, color: ::CLI::UI::Color).returns(::String) }
  def colorize_if_nonzero(num_str, rune, color); end

  # source://cli-ui//lib/cli/ui/widgets/status.rb#62
  sig { returns(::String) }
  def failed_part; end

  # source://cli-ui//lib/cli/ui/widgets/status.rb#73
  sig { returns(::String) }
  def pending_part; end

  # source://cli-ui//lib/cli/ui/widgets/status.rb#57
  sig { returns(::String) }
  def succeeded_part; end

  # source://cli-ui//lib/cli/ui/widgets/status.rb#67
  sig { returns(::String) }
  def working_part; end

  # source://cli-ui//lib/cli/ui/widgets/status.rb#46
  sig { params(num_str: ::String).returns(T::Boolean) }
  def zero?(num_str); end

  class << self
    # source://cli-ui//lib/cli/ui/widgets/status.rb#28
    sig { override.returns(::Regexp) }
    def argparse_pattern; end
  end
end

# source://cli-ui//lib/cli/ui/widgets/status.rb#10
CLI::UI::Widgets::Status::ARGPARSE_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://cli-ui//lib/cli/ui/widgets/status.rb#18
CLI::UI::Widgets::Status::ARROW = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/widgets/status.rb#17
CLI::UI::Widgets::Status::CLOSE = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/widgets/status.rb#19
CLI::UI::Widgets::Status::COMMA = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/widgets/status.rb#22
CLI::UI::Widgets::Status::EMPTY_SET = T.let(T.unsafe(nil), String)

# e.g. "1:23:3:404"
#
# source://cli-ui//lib/cli/ui/widgets/status.rb#16
CLI::UI::Widgets::Status::OPEN = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/widgets/status.rb#21
CLI::UI::Widgets::Status::SPINNER_STOPPED = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/wrap.rb#11
class CLI::UI::Wrap
  # source://cli-ui//lib/cli/ui/wrap.rb#15
  sig { params(input: ::String).void }
  def initialize(input); end

  # source://cli-ui//lib/cli/ui/wrap.rb#20
  sig { returns(::String) }
  def wrap; end
end
